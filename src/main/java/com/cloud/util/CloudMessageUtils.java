/*************************************************************************
 *
 *  HCL Technologies..... CONFIDENTIAL
 * _________________________________________________________________________________
 *
 * Copyright 2020 HCL Technologies. All rights reserved.
 *
 * NOTICE: All information contained herein is, and remains the property of HCL Technologies.
 *
 *************************************************************************/
// Author : Generated by ADvantageCloud
// Revision History :

package com.cloud.util;

import com.google.api.core.ApiFuture;
import com.google.api.core.ApiFutureCallback;
import com.google.api.core.ApiFutures;
import com.google.api.gax.rpc.ApiException;
import com.google.cloud.ServiceOptions;
import com.google.cloud.pubsub.v1.AckReplyConsumer;
import com.google.cloud.pubsub.v1.MessageReceiver;
import com.google.cloud.pubsub.v1.Publisher;
import com.google.cloud.pubsub.v1.Subscriber;
import com.google.common.collect.ImmutableMap;
import com.google.common.util.concurrent.MoreExecutors;
import com.google.protobuf.ByteString;
import com.google.pubsub.v1.ProjectSubscriptionName;
import com.google.pubsub.v1.ProjectTopicName;
import com.google.pubsub.v1.PubsubMessage;
import com.presto.banking.actionForm.Emp_AddTrans;
import com.presto.banking.util.ReadPropertyFile;
import org.apache.log4j.Logger;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * This util class is used to publish and subscribe the message from Cloud
 * Pub/Sub
 */
public class CloudMessageUtils {
	private static final Logger logger = Logger.getLogger(CloudMessageUtils.class);

	private static final String PROJECT_ID = ServiceOptions.getDefaultProjectId();

	/**
	 * This method is used to publish the message in pub/sub
	 *
	 * @param topicId  Topic Name for the message to be send
	 * @param message  Message to be send
	 * @param metaData additional data for along with message
	 * @throws InterruptedException
	 * @throws IOException
	 */
	public static void publishMessage(Emp_AddTrans depo) throws InterruptedException, IOException {

		// ProjectTopicName topicName = ProjectTopicName.of(PROJECT_ID,
		// prop.get("messaging.publisher.topic").toString());
		// Publisher publisher = null;
		// Properties prop = new ReadPropertyFile().config();

		Properties prop = new Properties();
		InputStream gcpinputStream = CloudMessageUtils.class.getClassLoader().getResourceAsStream("gcpcloudconfig.properties");
		try {
			prop.load(gcpinputStream);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		ProjectTopicName topicName = ProjectTopicName.of(PROJECT_ID, prop.get("messaging.publisher.topic").toString());
		Publisher publisher = null;

		String message = "Amount " + depo.getAmount() + " added successfully";
		ImmutableMap<String, String> metaData = ImmutableMap.of("clid", depo.getClid(), "details", depo.getDetails(),
				"depos", depo.getAmount());

		try {
			publisher = Publisher.newBuilder(topicName).build();
			ByteString data = ByteString.copyFromUtf8(message);
			PubsubMessage pubsubMessage = PubsubMessage.newBuilder().setData(data).putAllAttributes(metaData).build();
			ApiFuture<String> future = publisher.publish(pubsubMessage);

			ApiFutures.addCallback(future, new ApiFutureCallback<String>() {

				@Override
				public void onFailure(Throwable throwable) {
					if (throwable instanceof ApiException) {
						ApiException apiException = ((ApiException) throwable);
						// details on the API exception
						logger.info(apiException.getStatusCode().getCode());
						logger.info(apiException.isRetryable());
					}
					logger.info("Error publishing message : " + message);
				}

				@Override
				public void onSuccess(String messageId) {
					// Once published, returns server-assigned message ids (unique within the topic)
					logger.info("Published message ID: " + messageId);
				}
			}, MoreExecutors.directExecutor());

		} finally {
			if (publisher != null) {
				// When finished with the publisher, shutdown to free up resources.
				publisher.shutdown();
				publisher.awaitTermination(
						Long.parseLong(prop.get("messaging.publisher.termination.timeout").toString()),
						TimeUnit.SECONDS);
			}
		}
	}

	/**
	 * This method is used to subscribe the message from Cloud Pub/Sub
	 *
	 * @param subscriptionId Subscription Topic from where we need to get the
	 *                       message
	 * @return
	 * @throws IOException
	 */
	public static Emp_AddTrans subscribeMessage() throws IOException {
		// Properties prop = new ReadPropertyFile().config();

		Emp_AddTrans response = new Emp_AddTrans();

		Properties prop = new Properties();
		InputStream gcpinputStream = CloudMessageUtils.class.getClassLoader().getResourceAsStream("gcpcloudconfig.properties");
		try {
			prop.load(gcpinputStream);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		Map<String, String> data = new HashMap<>();
		ProjectSubscriptionName subscriptionName = ProjectSubscriptionName.of(PROJECT_ID,
				prop.get("messaging.subscriber.topic").toString());

		// Instantiate an asynchronous message receiver.
		MessageReceiver receiver = (PubsubMessage message, AckReplyConsumer consumer) -> {
			// Handle incoming message, then ack the received message.
			logger.info("Id: " + message.getMessageId());
			logger.info("Data: " + message.getData().toStringUtf8());
			data.put("message", message.getData().toStringUtf8());
			message.getAttributesMap().forEach((key, value) -> {
				data.put(key, value);
				logger.info("Metadata " + key + " : " + value);
			});

			response.setClid(data.get("clid"));
			response.setDetails(data.get("details"));
			response.setAmount(data.get("depos"));
			consumer.ack();
		};

		Subscriber subscriber = null;
		try {
			subscriber = Subscriber.newBuilder(subscriptionName, receiver).build();
			// Start the subscriber.
			subscriber.startAsync().awaitRunning();
			logger.info("Listening for messages on " + subscriptionName.toString());
			// Allow the subscriber to run for 30s unless an unrecoverable error occurs.
			subscriber.awaitTerminated(Long.parseLong(prop.get("messaging.subscriber.termination.timeout").toString()),
					TimeUnit.SECONDS);
		} catch (TimeoutException timeoutException) {
			// Shut down the subscriber after 30s. Stop receiving messages.
			subscriber.stopAsync();
		}
		return response;
	}
}